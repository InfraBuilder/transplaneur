#!/bin/bash


# Default period to wait for gateway to be available
export NETWORKS_TO_ROUTE="default"

# Default debug level
export DEBUG_LEVEL=${DEBUG_LEVEL:-2}          

# Default period to wait for gateway to be available
export WAIT_GATEWAY_PERIOD=${WAIT_GATEWAY_PERIOD:-5}

export TRANSPLANEUR_RUN_DIR=/var/run/transplaneur

#===/ Utility functions \======================================================

# Trick to no depend on locale (do not remove)
export LC_ALL=C

function logdate { date "+%Y-%m-%d %H:%M:%S"; }
function fatal { echo "$(logdate) [FATAL] $@" >&2; exit 1; }
function err { echo "$(logdate) [ERROR] $@" >&2; }
function warn { [ $DEBUG_LEVEL -ge 1 ] && echo "$(logdate) [WARNING] $@" >&2; }
function info { [ $DEBUG_LEVEL -ge 2 ] && echo "$(logdate) [INFO] $@" >&2; }
function debug { [ $DEBUG_LEVEL -ge 3 ] && echo "$(logdate) [DEBUG] $@" >&2; }
function now { date +%s; }

#===/ Detection \==============================================================

# Detect the network configuration
info "Detecting default interface"
DEFAULT_INTERFACE=$(ip route show default | awk '/default/ {print $5}')

info "Detecting private IP address of the pod"
LOCAL_PRIVATE_IP=$(ip addr show $DEFAULT_INTERFACE | grep "inet\b" | awk '{print $2}' | cut -d/ -f1)

info "Detecting public IP address of the host"
LOCAL_PUBLIC_IP=$(curl -s ifconfig.io)

info "Detecting default gateway"
ORIGINAL_GATEWAY=$(ip route show default | awk '/default/ {print $3}')

info "Summary of detected network configuration"
info "  Default interface: $DEFAULT_INTERFACE"
info "  Local private IP: $LOCAL_PRIVATE_IP"
info "  Local public IP: $LOCAL_PUBLIC_IP"
info "  Original gateway: $ORIGINAL_GATEWAY"

#===/ Init \===================================================================

info "Backup original routing table"
ip r > ${TRANSPLANEUR_RUN_DIR}/original-routes

#===/ Signal handling \========================================================

# Trap handler to restore original routing table
function trapHandlerRestore { 
    info "Signal $1 detected, exiting"
    exit
}

# Catching Signals
info "Catching signals to restore original routing table"
for i in SIGTERM SIGINT SIGKILL SIGQUIT SIGSTOP SIGABRT; do
    trap "trapHandlerRestore $i" $i
done


#===/ Routing \================================================================

function ensureRouteIsSet {
    # Retrieve the route to check
    ROUTE=$1

    # Check if the route is already set
    if ! ip r | grep -q "$ROUTE"; then
        info "  Adding route '$ROUTE'"
        ip r add $ROUTE
    fi
}

function changeGateway {
    # Retrieve the gateway IP address
    GATEWAY_IP=$1

    # Create routes for pod and services CIDR
    info "Checking routes for pod and services CIDR"
    for i in $CLUSTER_POD_CIDR $CLUSTER_SERVICE_CIDR; do
        ensureRouteIsSet "$i via $ORIGINAL_GATEWAY dev $DEFAULT_INTERFACE"
    done

    info "Changing routes gateway to $GATEWAY_IP"
    for i in $NETWORKS_TO_ROUTE; do
        info "  Route $i"
        [ "$(ip r show $i)" = "" ] || ip r del $i
        ip r add $i via $GATEWAY_IP
    done

    # Flush the ARP cache
    ip n flush all
}

# Starting with no gateway to force the first update
CURRENT_GATEWAY=""

# Watch for changes in the gateway
while true; do

    # Wait for the gateway to be available
    while [ ! -r ${TRANSPLANEUR_RUN_DIR}/local-gateway ]; do
        warn "Waiting for gateway to be available ..."
        sleep ${WAIT_GATEWAY_PERIOD}
    done

    # If the gateway has changed, update the routing table
    debug "Check if gateway has changed from current : $CURRENT_GATEWAY"
    if [ "$CURRENT_GATEWAY" != "$(cat ${TRANSPLANEUR_RUN_DIR}/local-gateway)" ]; then
        PREVIOUS_GATEWAY=$CURRENT_GATEWAY
        
        CURRENT_GATEWAY=$(cat ${TRANSPLANEUR_RUN_DIR}/local-gateway)
        
        CLUSTER_POD_CIDR=$(cat ${TRANSPLANEUR_RUN_DIR}/cluster-pod-cidr)
        CLUSTER_SERVICE_CIDR=$(cat ${TRANSPLANEUR_RUN_DIR}/cluster-svc-cidr)

        info "Gateway changed from $PREVIOUS_GATEWAY to $CURRENT_GATEWAY"
        changeGateway $CURRENT_GATEWAY
    fi

    sleep 1
done 
